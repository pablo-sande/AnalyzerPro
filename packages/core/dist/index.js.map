{"version":3,"sources":["../src/index.ts","../src/analyzer.ts","../src/traverser.ts"],"sourcesContent":["export * from './types.js';\r\nexport * from './analyzer.js'; ","import * as fs from 'fs';\nimport * as path from 'path';\nimport { AnalysisResult, FileAnalysis, FunctionMetrics } from './types.js';\nimport type { \n  Node as BabelNode,\n  FunctionDeclaration, \n  ArrowFunctionExpression, \n  FunctionExpression,\n  VariableDeclarator,\n  ObjectProperty,\n  ClassMethod,\n  AssignmentExpression,\n  ExportDefaultDeclaration,\n  ExportNamedDeclaration,\n  ObjectMethod,\n  ClassProperty,\n  CallExpression,\n  JSXAttribute,\n  Identifier,\n  StringLiteral,\n  NumericLiteral,\n  MemberExpression\n} from '@babel/types';\nimport { parseFile, traverse, calculateComplexity } from './traverser.js';\n\ninterface ParentInfo {\n  type: string;\n  key?: string;\n  value?: string | number;\n  method?: string;\n  parent?: {\n    type: string;\n    callee?: {\n      name: string;\n    };\n  };\n}\n\nexport class CodeAnalyzer {\n  private readonly ARRAY_METHODS = ['map', 'filter', 'forEach', 'find', 'some', 'every', 'reduce'] as const;\n  private readonly PROMISE_METHODS = ['then', 'catch', 'finally'] as const;\n  private readonly REACT_HOOKS = ['useEffect', 'useCallback', 'useMemo', 'useState', 'useRef', 'useContext'] as const;\n  private readonly COMPLEXITY_THRESHOLD = 10;\n  private readonly LINES_THRESHOLD = 50;\n  private readonly DUPLICATION_THRESHOLD = 0.8;\n  private readonly CACHE_SIZE = 1000;\n\n  private readonly FUNCTION_TYPES = {\n    METHOD: 'method' as const,\n    PROMISE: 'promise' as const,\n    ARRAY: 'array' as const,\n    HOOK: 'hook' as const,\n    CALLBACK: 'callback' as const,\n    FUNCTION: 'function' as const\n  } as const;\n\n  private complexityCache: Map<string, number> = new Map();\n  private fanInCache: Map<string, number> = new Map();\n  private fanOutCache: Map<string, number> = new Map();\n\n  private clearCaches() {\n    this.complexityCache.clear();\n    this.fanInCache.clear();\n    this.fanOutCache.clear();\n  }\n\n  private getCacheKey(node: BabelNode): string {\n    return `${node.type}-${node.loc?.start.line}-${node.loc?.start.column}`;\n  }\n\n  public async parseFile(filePath: string): Promise<FileAnalysis> {\n    this.clearCaches();\n    const content = await fs.promises.readFile(filePath, 'utf-8');\n    \n    // Verificar tamaño del archivo antes de procesarlo\n    if (content.length > 1024 * 1024) { // 1MB\n      console.warn(`File ${filePath} is too large (${content.length} bytes), skipping detailed analysis`);\n      return {\n        path: filePath,\n        name: path.basename(filePath),\n        extension: path.extname(filePath),\n        totalLines: content.split('\\n').length,\n        functions: [],\n        functionsCount: 0,\n        complexity: 0,\n        maxComplexity: 0,\n        averageFanIn: 0,\n        averageFanOut: 0,\n        duplicationPercentage: 0,\n        warningCount: 0,\n        fileSize: content.length\n      };\n    }\n\n    const ast = parseFile(content);  \n    const functions: FunctionMetrics[] = [];\n    const lines = content.split('\\n');\n    const totalLines = lines.length;\n    let totalComplexity = 0;\n    let maxComplexity = 0;\n    let totalFanIn = 0;\n    let totalFanOut = 0;\n    let totalWarnings = 0;\n    let totalDuplication = 0;\n\n    // Pre-calcular las líneas únicas para la detección de duplicación\n    const uniqueLines = new Set(lines.map(line => line.trim())\n      .filter(line => line.length > 0 && !line.startsWith('//') && !line.startsWith('/*')));\n\n    traverse(ast, {\n      onFunction: (node: FunctionDeclaration | ArrowFunctionExpression | FunctionExpression, parent?: ParentInfo) => {\n        let functionName = 'anonymous';\n        let functionType: FunctionMetrics['type'] = this.FUNCTION_TYPES.FUNCTION;\n\n        // Si es una función nombrada, usar ese nombre\n        if ('id' in node && node.id) {\n          functionName = node.id.name;\n        }\n        // Si es un método de clase o propiedad de objeto\n        else if (parent && (parent.type === 'ClassMethod' || parent.type === 'ObjectProperty')) {\n          functionName = parent.key || 'anonymous';\n          functionType = this.FUNCTION_TYPES.METHOD;\n        }\n        // Si es una declaración de variable\n        else if (parent && parent.type === 'VariableDeclarator') {\n          functionName = parent.key || 'anonymous';\n        }\n        // Si es un callback en un CallExpression\n        else if (parent && parent.type === 'CallExpression') {\n          // Verificar si es un hook de React\n          const findClosestHook = (node: any): string | null => {\n            if (!node) return null;\n            \n            // Verificar si el nodo actual es una llamada a un hook\n            if (node.type === 'CallExpression' && \n                node.callee?.type === 'Identifier' && \n                this.REACT_HOOKS.includes(node.callee.name)) {\n              return node.callee.name;\n            }\n            \n            // Verificar si el nodo es un argumento de un hook\n            if (node.parent?.type === 'CallExpression' && \n                node.parent.callee?.type === 'Identifier' && \n                this.REACT_HOOKS.includes(node.parent.callee.name)) {\n              return node.parent.callee.name;\n            }\n            \n            return findClosestHook(node.parent);\n          };\n\n          const hookName = findClosestHook(node);\n          if (hookName) {\n            functionName = `${hookName} callback`;\n            functionType = this.FUNCTION_TYPES.HOOK;\n          }\n          else if (parent.method) {\n            if (this.PROMISE_METHODS.includes(parent.method as typeof this.PROMISE_METHODS[number])) {\n              functionName = `${parent.method} handler`;\n              functionType = this.FUNCTION_TYPES.PROMISE;\n            }\n            else if (this.ARRAY_METHODS.includes(parent.method as typeof this.ARRAY_METHODS[number])) {\n              functionName = `${parent.method} callback`;\n              functionType = this.FUNCTION_TYPES.ARRAY;\n            }\n            else {\n              functionName = `${parent.method} callback`;\n              functionType = this.FUNCTION_TYPES.CALLBACK;\n            }\n          }\n          else if (parent.key) {\n            functionName = `${parent.key} callback`;\n            functionType = this.FUNCTION_TYPES.CALLBACK;\n          }\n          else {\n            functionName = 'anonymous callback';\n            functionType = this.FUNCTION_TYPES.CALLBACK;\n          }\n        }\n\n        // Calcular métricas con caché\n        const cacheKey = this.getCacheKey(node);\n        let complexity = this.complexityCache.get(cacheKey);\n        if (complexity === undefined) {\n          complexity = calculateComplexity(node);\n          this.complexityCache.set(cacheKey, complexity);\n        }\n\n        const functionLines = node.loc ? node.loc.end.line - node.loc.start.line + 1 : 0;\n        const startLine = node.loc ? node.loc.start.line : 0;\n\n        // Actualizar métricas globales\n        totalComplexity += complexity;\n        maxComplexity = Math.max(maxComplexity, complexity);\n\n        // Calcular fan-in y fan-out con caché\n        let fanIn = this.fanInCache.get(cacheKey);\n        if (fanIn === undefined) {\n          fanIn = this.calculateFanIn(node, ast);\n          this.fanInCache.set(cacheKey, fanIn);\n        }\n\n        let fanOut = this.fanOutCache.get(cacheKey);\n        if (fanOut === undefined) {\n          fanOut = this.calculateFanOut(node, ast);\n          this.fanOutCache.set(cacheKey, fanOut);\n        }\n\n        totalFanIn += fanIn;\n        totalFanOut += fanOut;\n\n        // Detectar warnings\n        const hasWarning = functionLines > this.LINES_THRESHOLD || complexity > this.COMPLEXITY_THRESHOLD;\n        if (hasWarning) {\n          totalWarnings++;\n        }\n\n        // Calcular duplicación para esta función\n        const functionContent = lines\n          .slice(\n            (node.loc?.start.line || 1) - 1,\n            node.loc?.end.line || 1\n          )\n          .join('\\n');\n        const duplication = this.calculateFunctionDuplication(functionContent);\n        totalDuplication += duplication;\n\n        const functionInfo: FunctionMetrics = {\n          name: functionName,\n          lines: functionLines,\n          startLine,\n          complexity,\n          fanIn,\n          fanOut,\n          type: functionType,\n          hasWarning\n        };\n\n        functions.push(functionInfo);\n      },\n    });\n\n    // Get file stats for file size\n    const stats = await fs.promises.stat(filePath);\n\n    // Calculate average complexity for the file\n    const complexity = functions.length > 0 ? totalComplexity / functions.length : 0;\n    const duplicationPercentage = functions.length > 0 ? totalDuplication / functions.length : 0;\n\n    return {\n      path: filePath,\n      name: path.basename(filePath),\n      extension: path.extname(filePath),\n      totalLines,\n      functions,\n      functionsCount: functions.length,\n      complexity,\n      maxComplexity,\n      averageFanIn: functions.length > 0 ? totalFanIn / functions.length : 0,\n      averageFanOut: functions.length > 0 ? totalFanOut / functions.length : 0,\n      duplicationPercentage,\n      warningCount: totalWarnings,\n      fileSize: stats.size\n    };\n  }\n\n  private calculateFanIn(node: BabelNode, ast: BabelNode): number {\n    // Implementación simplificada: contar referencias a la función\n    let fanIn = 0;\n    traverse(ast, {\n      onFunction: (funcNode) => {\n        if (funcNode !== node && this.hasReferenceToNode(funcNode, node)) {\n          fanIn++;\n        }\n      }\n    });\n    return fanIn;\n  }\n\n  private calculateFanOut(node: BabelNode, ast: BabelNode): number {\n    // Implementación simplificada: contar llamadas a otras funciones\n    let fanOut = 0;\n    traverse(ast, {\n      onControlFlow: (controlNode) => {\n        if (this.isNodeInsideFunction(controlNode, node) && \n            controlNode.type === 'CallExpression') {\n          fanOut++;\n        }\n      }\n    });\n    return fanOut;\n  }\n\n  private hasReferenceToNode(node: BabelNode, targetNode: BabelNode): boolean {\n    // Implementación simplificada: verificar si el nodo hace referencia al nodo objetivo\n    if (!node || !targetNode) return false;\n    \n    if (node.type === 'CallExpression' && \n        (node as any).callee?.type === 'Identifier' &&\n        (node as any).callee?.name === (targetNode as any).id?.name) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private isNodeInsideFunction(node: BabelNode, functionNode: BabelNode): boolean {\n    // Implementación simplificada: verificar si el nodo está dentro de la función\n    if (!node.loc || !functionNode.loc) return false;\n    \n    return node.loc.start.line >= functionNode.loc.start.line &&\n           node.loc.end.line <= functionNode.loc.end.line;\n  }\n\n  private calculateFunctionDuplication(content: string): number {\n    const lines = content.split('\\n')\n      .map(line => line.trim())\n      .filter(line => line.length > 0 && !line.startsWith('//') && !line.startsWith('/*'));\n\n    if (lines.length === 0) return 0;\n\n    const uniqueLines = new Set(lines);\n    return (lines.length - uniqueLines.size) / lines.length;\n  }\n\n  public async analyzeRepo(repoPath: string): Promise<AnalysisResult> {\n    const files: FileAnalysis[] = [];\n    const jsExtensions = ['.js', '.jsx', '.ts', '.tsx'];\n    const BATCH_SIZE = 50; // Procesar archivos en lotes de 50\n    let currentBatch: string[] = [];\n\n    const processDirectory = async (dirPath: string) => {\n      const entries = await fs.promises.readdir(dirPath, { withFileTypes: true });\n      \n      for (const entry of entries) {\n        const fullPath = path.join(dirPath, entry.name);\n        \n        if (entry.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules' && entry.name !== 'dist' && entry.name !== 'build') {\n          await processDirectory(fullPath);\n        } else if (entry.isFile() && jsExtensions.includes(path.extname(entry.name)) && !entry.name.includes('dist') && !entry.name.includes('build') && !entry.name.includes('_astro') && !entry.name.includes('mocks')) {\n          currentBatch.push(fullPath);\n          \n          if (currentBatch.length >= BATCH_SIZE) {\n            await processBatch();\n          }\n        }\n      }\n    };\n\n    const processBatch = async () => {\n      if (currentBatch.length === 0) return;\n      \n      const batchResults = await Promise.all(\n        currentBatch.map(async (filePath) => {\n          try {\n            return await this.parseFile(filePath);\n          } catch (error) {\n            console.error(`Error analyzing ${filePath}:`, error);\n            return null;\n          }\n        })\n      );\n\n      files.push(...batchResults.filter((result): result is FileAnalysis => result !== null));\n      currentBatch = [];\n    };\n\n    await processDirectory(repoPath);\n    await processBatch(); // Procesar el último lote si queda alguno\n\n    const summary = {\n      totalFiles: files.length,\n      totalLines: files.reduce((sum, file) => sum + file.totalLines, 0),\n      functionsOver50Lines: files.reduce((sum, file) => \n        sum + file.functions.filter((f: FunctionMetrics) => f.lines > 50).length, 0),\n      functionsOverComplexity10: files.reduce((sum, file) => \n        sum + file.functions.filter((f: FunctionMetrics) => f.complexity > 10).length, 0),\n      averageComplexity: files.reduce((sum, file) => \n        sum + file.functions.reduce((fSum: number, f: FunctionMetrics) => fSum + f.complexity, 0), 0) / \n        files.reduce((sum, file) => sum + file.functions.length, 0),\n      averageDuplication: files.reduce((sum, file) => \n        sum + file.duplicationPercentage, 0) / files.length,\n    };\n\n    return { files, summary };\n  }\n} ","import { parse } from '@babel/parser';\r\nimport type { \r\n  Node as BabelNode, \r\n  FunctionDeclaration, \r\n  ArrowFunctionExpression,\r\n  FunctionExpression,\r\n  IfStatement, \r\n  SwitchCase, \r\n  ForStatement, \r\n  WhileStatement, \r\n  DoWhileStatement, \r\n  CatchClause, \r\n  ConditionalExpression,\r\n  VariableDeclarator,\r\n  ObjectProperty,\r\n  ClassMethod,\r\n  AssignmentExpression,\r\n  ExportDefaultDeclaration,\r\n  ExportNamedDeclaration,\r\n  ObjectMethod,\r\n  ClassProperty,\r\n  CallExpression,\r\n  JSXAttribute,\r\n  MemberExpression\r\n} from '@babel/types';\r\n\r\ninterface FunctionContext {\r\n  type: string;\r\n  objectName?: string;\r\n  method?: string;\r\n  isOptional?: boolean;\r\n  parent?: FunctionContext;\r\n  loc?: {\r\n    start: { line: number; column: number };\r\n    end: { line: number; column: number };\r\n  } | null;\r\n}\r\n\r\nclass ContextualNamingSystem {\r\n  private contextStack: FunctionContext[] = [];\r\n  private namedFunctions: Map<string, string> = new Map();\r\n  private targetFile: string | null = null;\r\n  private readonly CACHE_KEY_SEPARATOR = '::';\r\n\r\n  private generateCacheKey(node: BabelNode, context?: FunctionContext): string {\r\n    const nodeId = `${node.type}-${node.loc?.start.line}-${node.loc?.start.column}`;\r\n    const contextId = context ? `${context.type}-${context.method || ''}-${context.objectName || ''}` : 'no-context';\r\n    return `${nodeId}${this.CACHE_KEY_SEPARATOR}${contextId}`;\r\n  }\r\n\r\n  public pushContext(context: FunctionContext) {\r\n    if (this.contextStack.length > 0) {\r\n      context.parent = this.contextStack[this.contextStack.length - 1];\r\n    }\r\n    this.contextStack.push(context);\r\n  }\r\n\r\n  public popContext() {\r\n    this.contextStack.pop();\r\n  }\r\n\r\n  private getCurrentContext(): FunctionContext | undefined {\r\n    return this.contextStack[this.contextStack.length - 1];\r\n  }\r\n\r\n  public generateName(node: BabelNode, parent?: BabelNode): string {\r\n    const currentContext = this.getCurrentContext();\r\n    \r\n    // Intentar obtener el nombre del caché\r\n    const cacheKey = this.generateCacheKey(node, currentContext);\r\n    const cachedName = this.namedFunctions.get(cacheKey);\r\n    if (cachedName) {\r\n      return cachedName;\r\n    }\r\n    \r\n    if (!currentContext) {\r\n      return 'anonymous';\r\n    }\r\n\r\n    // Mapeo de tipos de contexto a nombres de función\r\n    const contextNameMappings: Record<string, (context: FunctionContext) => string> = {\r\n      OptionalCallExpression: (ctx) => `${ctx.objectName}?.${ctx.method} callback`,\r\n      CallExpression: (ctx) => {\r\n        if (ctx.method) {\r\n          // Detectar tipos específicos de callbacks\r\n          if (['then', 'catch', 'finally'].includes(ctx.method)) {\r\n            return `${ctx.method} handler`;\r\n          }\r\n          if (['map', 'filter', 'forEach', 'find', 'some', 'every', 'reduce'].includes(ctx.method)) {\r\n            return `${ctx.method} callback`;\r\n          }\r\n          if (ctx.method.startsWith('use')) {\r\n            return `${ctx.method} callback`;\r\n          }\r\n          return `${ctx.objectName}.${ctx.method} callback`;\r\n        }\r\n        return 'anonymous';\r\n      },\r\n      JSXExpressionContainer: (ctx) => `${ctx.objectName}.${ctx.method} callback`\r\n    };\r\n\r\n    // Intentar obtener el nombre usando el mapeo\r\n    const mapping = contextNameMappings[currentContext.type];\r\n    let name = 'anonymous';\r\n    \r\n    if (mapping) {\r\n      name = mapping(currentContext);\r\n    } else if (node.type === 'FunctionDeclaration' && (node as any).id?.name) {\r\n      name = (node as any).id.name;\r\n    }\r\n\r\n    // Guardar en el caché\r\n    this.namedFunctions.set(cacheKey, name);\r\n    return name;\r\n  }\r\n\r\n  public extractContextFromNode(node: BabelNode): FunctionContext | null {\r\n    // Mapeo de tipos de nodo a funciones de extracción de contexto\r\n    const contextExtractors: Record<string, (node: BabelNode) => FunctionContext | null> = {\r\n      OptionalCallExpression: (node) => {\r\n        const callee = (node as any).callee;\r\n        if (callee?.type === 'OptionalMemberExpression') {\r\n          return {\r\n            type: 'OptionalCallExpression',\r\n            objectName: callee.object?.name || 'object',\r\n            method: callee.property?.name,\r\n            isOptional: true,\r\n            loc: node.loc ? {\r\n              start: { line: node.loc.start.line, column: node.loc.start.column },\r\n              end: { line: node.loc.end.line, column: node.loc.end.column }\r\n            } : null\r\n          };\r\n        }\r\n        return null;\r\n      },\r\n      CallExpression: (node) => {\r\n        const callee = (node as any).callee;\r\n        if (callee?.type === 'MemberExpression') {\r\n          return {\r\n            type: 'CallExpression',\r\n            objectName: callee.object?.name || 'object',\r\n            method: callee.property?.name,\r\n            loc: node.loc ? {\r\n              start: { line: node.loc.start.line, column: node.loc.start.column },\r\n              end: { line: node.loc.end.line, column: node.loc.end.column }\r\n            } : null\r\n          };\r\n        }\r\n        return null;\r\n      },\r\n      JSXExpressionContainer: (node) => {\r\n        const expression = (node as any).expression;\r\n        if (expression?.type === 'CallExpression') {\r\n          const callee = expression.callee;\r\n          if (callee?.type === 'MemberExpression') {\r\n            return {\r\n              type: 'JSXExpressionContainer',\r\n              objectName: callee.object?.name || 'object',\r\n              method: callee.property?.name,\r\n              loc: node.loc ? {\r\n                start: { line: node.loc.start.line, column: node.loc.start.column },\r\n                end: { line: node.loc.end.line, column: node.loc.end.column }\r\n              } : null\r\n            };\r\n          }\r\n        }\r\n        return null;\r\n      }\r\n    };\r\n\r\n    // Intentar extraer el contexto usando el mapeo\r\n    const extractor = contextExtractors[node.type as keyof typeof contextExtractors];\r\n    if (extractor) {\r\n      const context = extractor(node);\r\n      if (context) {\r\n        return context;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\ninterface NodeInfo {\r\n  node: BabelNode;\r\n  parent?: {\r\n    type: string;\r\n    key?: string;\r\n    value?: string;\r\n    method?: string;\r\n    isOptional?: boolean;\r\n  };\r\n}\r\n\r\nexport interface TraverseOptions {\r\n  onFunction?: (node: FunctionDeclaration | ArrowFunctionExpression | FunctionExpression, parent?: NodeInfo['parent']) => void;\r\n  onControlFlow?: (node: BabelNode) => void;\r\n}\r\n\r\nfunction getParentInfo(parent: BabelNode | undefined): NodeInfo['parent'] {\r\n  if (!parent) return undefined;\r\n\r\n  // Mapeo de tipos de nodo a sus propiedades de nombre\r\n  const nameMappings = {\r\n    VariableDeclarator: (p: any) => ({ type: 'VariableDeclarator', key: p.id?.name }),\r\n    ObjectProperty: (p: any) => ({ type: 'ObjectProperty', key: p.key?.name }),\r\n    ClassMethod: (p: any) => ({ type: 'ClassMethod', key: p.key?.name }),\r\n    AssignmentExpression: (p: any) => ({ type: 'AssignmentExpression', key: p.left?.name }),\r\n    ExportDefaultDeclaration: () => ({ type: 'ExportDefaultDeclaration', key: 'default' }),\r\n    ObjectMethod: (p: any) => ({ type: 'ObjectMethod', key: p.key?.name }),\r\n    ClassProperty: (p: any) => ({ type: 'ClassProperty', key: p.key?.name }),\r\n    JSXAttribute: (p: any) => ({ type: 'JSXAttribute', key: p.name?.name })\r\n  };\r\n\r\n  // Intentar obtener el nombre usando el mapeo\r\n  const mapping = nameMappings[parent.type as keyof typeof nameMappings];\r\n  if (mapping) {\r\n    return mapping(parent);\r\n  }\r\n\r\n  // Manejar ExportNamedDeclaration de forma especial\r\n  if (parent.type === 'ExportNamedDeclaration') {\r\n    const declaration = (parent as any).declaration;\r\n    if (declaration) {\r\n      if (declaration.type === 'VariableDeclaration') {\r\n        const firstDeclarator = declaration.declarations[0];\r\n        if (firstDeclarator?.id?.name) {\r\n          return { type: 'ExportNamedDeclaration', key: firstDeclarator.id.name };\r\n        }\r\n      } else if (declaration.id?.name) {\r\n        return { type: 'ExportNamedDeclaration', key: declaration.id.name };\r\n      }\r\n    }\r\n  }\r\n\r\n  // Manejar CallExpression de forma especial\r\n  if (parent.type === 'CallExpression') {\r\n    const callee = (parent as any).callee;\r\n    if (callee?.type === 'Identifier') {\r\n      return {\r\n        type: 'CallExpression',\r\n        key: callee.name,\r\n        method: callee.name,\r\n        value: `${callee.name} callback`\r\n      };\r\n    }\r\n    else if (callee?.type === 'MemberExpression' || callee?.type === 'OptionalMemberExpression') {\r\n      const methodName = callee.property?.name || 'unknown';\r\n      const objectName = callee.object?.name || 'object';\r\n      const isOptional = callee.type === 'OptionalMemberExpression';\r\n\r\n      return {\r\n        type: 'CallExpression',\r\n        key: objectName,\r\n        method: methodName,\r\n        isOptional,\r\n        value: `${methodName} callback`\r\n      };\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\nexport function traverse(node: BabelNode, options: TraverseOptions, parent?: BabelNode) {\r\n  if (!node) return;\r\n\r\n  const namingSystem = new ContextualNamingSystem();\r\n  // Handle all types of functions\r\n  if (\r\n    (node.type === 'FunctionDeclaration' || \r\n     node.type === 'ArrowFunctionExpression' || \r\n     node.type === 'FunctionExpression') && \r\n    options.onFunction\r\n  ) {\r\n    const parentInfo = getParentInfo(parent);\r\n    const context = namingSystem.extractContextFromNode(parent as BabelNode);\r\n    \r\n    if (context) {\r\n      namingSystem.pushContext(context);\r\n    }\r\n\r\n    // Determinar el nombre de la función\r\n    let functionName = 'anonymous';\r\n\r\n    // 1. Intentar obtener el nombre del nodo si es una función declarada\r\n    if (node.type === 'FunctionDeclaration' && (node as any).id?.name) {\r\n      functionName = (node as any).id.name;\r\n    }\r\n    // 2. Intentar obtener el nombre del parentInfo\r\n    else if (parentInfo) {\r\n      if (parentInfo.type === 'CallExpression') {\r\n        functionName = parentInfo.value || `${parentInfo.method} callback`;\r\n      } else if (parentInfo.key) {\r\n        functionName = parentInfo.key;\r\n      }\r\n    }\r\n    // 3. Intentar obtener el nombre del contexto\r\n    else if (context) {\r\n      functionName = namingSystem.generateName(node, parent);\r\n    }\r\n\r\n    // Forzar el nombre en el nodo para funciones anónimas\r\n    if ((node.type === 'ArrowFunctionExpression' || node.type === 'FunctionExpression') && \r\n        functionName !== 'anonymous') {\r\n      (node as any).id = { type: 'Identifier', name: functionName };\r\n    }\r\n\r\n    // Llamar a onFunction con la información del padre\r\n    options.onFunction(node as FunctionDeclaration | ArrowFunctionExpression | FunctionExpression, {\r\n      type: parent?.type || 'unknown',\r\n      key: parentInfo?.key || functionName,\r\n      method: context?.method,\r\n      isOptional: context?.isOptional,\r\n      value: functionName\r\n    });\r\n\r\n    if (context) {\r\n      namingSystem.popContext();\r\n    }\r\n  }\r\n\r\n  // Handle control flow statements\r\n  if (\r\n    (node.type === 'IfStatement' ||\r\n     node.type === 'SwitchCase' ||\r\n     node.type === 'ForStatement' ||\r\n     node.type === 'WhileStatement' ||\r\n     node.type === 'DoWhileStatement' ||\r\n     node.type === 'CatchClause' ||\r\n     node.type === 'ConditionalExpression') &&\r\n    options.onControlFlow\r\n  ) {\r\n    options.onControlFlow(node);\r\n  }\r\n\r\n  // Recursively traverse child nodes\r\n  for (const key in node) {\r\n    const value = (node as any)[key];\r\n    if (value && typeof value === 'object') {\r\n      if (Array.isArray(value)) {\r\n        value.forEach(child => traverse(child, options, node));\r\n      } else if (value.type) {\r\n        traverse(value, options, node);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function calculateComplexity(node: BabelNode): number {\r\n  let complexity = 1; // Base complexity for the function itself\r\n\r\n  traverse(node, {\r\n    onControlFlow: () => {\r\n      complexity++; // Increment complexity for each control flow statement\r\n    }\r\n  });\r\n\r\n  return complexity;\r\n}\r\n\r\nexport function parseFile(content: string) {\r\n  return parse(content, {\r\n    sourceType: 'module',\r\n    plugins: ['typescript', 'jsx']\r\n  });\r\n} "],"mappings":"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","names":["node","node","complexity"]}