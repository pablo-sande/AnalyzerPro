{"version":3,"sources":["../src/index.ts","../src/traverser.ts","../src/analyzer.ts"],"sourcesContent":["// Export types\r\nexport type {\r\n  AnalysisResult,\r\n  FileAnalysis,\r\n  FunctionAnalysis,\r\n  FunctionMetrics,\r\n  TraverseOptions,\r\n  NodeInfo\r\n} from './types';\r\n\r\n// Export main classes/functions\r\nexport { traverse, parseFile } from './traverser';\r\nexport { CodeAnalyzer } from './analyzer';","import { parse } from '@babel/parser';\nimport type { \n  Node as BabelNode, \n  FunctionDeclaration, \n  ArrowFunctionExpression,\n  FunctionExpression,\n  IfStatement, \n  SwitchCase, \n  ForStatement, \n  WhileStatement, \n  DoWhileStatement, \n  CatchClause, \n  ConditionalExpression,\n  VariableDeclarator,\n  ObjectProperty,\n  ClassMethod,\n  AssignmentExpression,\n  ExportDefaultDeclaration,\n  ExportNamedDeclaration,\n  ObjectMethod,\n  ClassProperty,\n  CallExpression,\n  JSXAttribute,\n  MemberExpression\n} from '@babel/types';\n\ninterface FunctionContext {\n  type: string;\n  objectName?: string;\n  method?: string;\n  isOptional?: boolean;\n  parent?: FunctionContext;\n  loc?: {\n    start: { line: number; column: number };\n    end: { line: number; column: number };\n  } | null;\n}\n\nclass ContextualNamingSystem {\n  private contextStack: FunctionContext[] = [];\n  private namedFunctions: Map<string, string> = new Map();\n  private readonly CACHE_KEY_SEPARATOR = '::';\n\n  // Mapeo estático de tipos de contexto a nombres de función\n  private static readonly CONTEXT_NAME_MAPPINGS: Record<string, (ctx: FunctionContext) => string> = {\n    OptionalCallExpression: (ctx) => `${ctx.objectName}?.${ctx.method} callback`,\n    CallExpression: (ctx) => {\n      if (!ctx.method) return 'anonymous';\n      \n      // Detectar tipos específicos de callbacks\n      if (['then', 'catch', 'finally'].includes(ctx.method)) {\n        return `${ctx.method} handler`;\n      }\n      if (['map', 'filter', 'forEach', 'find', 'some', 'every', 'reduce'].includes(ctx.method)) {\n        return `${ctx.method} callback`;\n      }\n      if (ctx.method.startsWith('use')) {\n        return `${ctx.method} callback`;\n      }\n      return `${ctx.objectName}.${ctx.method} callback`;\n    },\n    JSXExpressionContainer: (ctx) => `${ctx.objectName}.${ctx.method} callback`\n  };\n\n  // Mapeo estático de tipos de nodo a extractores de contexto\n  private static readonly CONTEXT_EXTRACTORS: Record<string, (node: BabelNode) => FunctionContext | null> = {\n    OptionalCallExpression: (node) => {\n      const callee = (node as any).callee;\n      if (callee?.type === 'OptionalMemberExpression') {\n        return {\n          type: 'OptionalCallExpression',\n          objectName: callee.object?.name || 'object',\n          method: callee.property?.name,\n          isOptional: true,\n          loc: node.loc\n        };\n      }\n      return null;\n    },\n    CallExpression: (node) => {\n      const callee = (node as any).callee;\n      if (callee?.type === 'MemberExpression') {\n        return {\n          type: 'CallExpression',\n          objectName: callee.object?.name || 'object',\n          method: callee.property?.name,\n          loc: node.loc\n        };\n      }\n      return null;\n    },\n    JSXExpressionContainer: (node) => {\n      const expression = (node as any).expression;\n      if (expression?.type === 'CallExpression') {\n        const callee = expression.callee;\n        if (callee?.type === 'MemberExpression') {\n          return {\n            type: 'JSXExpressionContainer',\n            objectName: callee.object?.name || 'object',\n            method: callee.property?.name,\n            loc: node.loc\n          };\n        }\n      }\n      return null;\n    }\n  };\n\n  private generateCacheKey(node: BabelNode, context?: FunctionContext): string {\n    return `${node.type}-${node.loc?.start.line}-${node.loc?.start.column}${this.CACHE_KEY_SEPARATOR}${context?.type || 'no-context'}`;\n  }\n\n  public pushContext(context: FunctionContext) {\n    if (this.contextStack.length > 0) {\n      context.parent = this.contextStack[this.contextStack.length - 1];\n    }\n    this.contextStack.push(context);\n  }\n\n  public popContext() {\n    this.contextStack.pop();\n  }\n\n  private getCurrentContext(): FunctionContext | undefined {\n    return this.contextStack[this.contextStack.length - 1];\n  }\n\n  public generateName(node: BabelNode, parent?: BabelNode): string {\n    const currentContext = this.getCurrentContext();\n    \n    // Intentar obtener el nombre del caché\n    const cacheKey = this.generateCacheKey(node, currentContext);\n    const cachedName = this.namedFunctions.get(cacheKey);\n    if (cachedName) {\n      return cachedName;\n    }\n    \n    if (!currentContext) {\n      return 'anonymous';\n    }\n\n    // Intentar obtener el nombre usando el mapeo estático\n    const mapping = ContextualNamingSystem.CONTEXT_NAME_MAPPINGS[currentContext.type];\n    let name = 'anonymous';\n    \n    if (mapping) {\n      name = mapping(currentContext);\n    } else if (node.type === 'FunctionDeclaration' && (node as any).id?.name) {\n      name = (node as any).id.name;\n    }\n\n    // Guardar en el caché\n    this.namedFunctions.set(cacheKey, name);\n    return name;\n  }\n\n  public extractContextFromNode(node: BabelNode): FunctionContext | null {\n    const extractor = ContextualNamingSystem.CONTEXT_EXTRACTORS[node.type as keyof typeof ContextualNamingSystem.CONTEXT_EXTRACTORS];\n    return extractor ? extractor(node) : null;\n  }\n}\n\ninterface NodeInfo {\n  node: BabelNode;\n  parent?: {\n    type: string;\n    key?: string;\n    value?: string;\n    method?: string;\n    isOptional?: boolean;\n  };\n}\n\nexport interface TraverseOptions {\n  onFunction?: (node: FunctionDeclaration | ArrowFunctionExpression | FunctionExpression, parent?: NodeInfo['parent']) => void;\n  onControlFlow?: (node: BabelNode) => void;\n}\n\nfunction getParentInfo(parent: BabelNode | undefined): NodeInfo['parent'] {\n  if (!parent) return undefined;\n\n  // Mapeo de tipos de nodo a sus propiedades de nombre\n  const nameMappings = {\n    VariableDeclarator: (p: any) => ({ type: 'VariableDeclarator', key: p.id?.name }),\n    ObjectProperty: (p: any) => ({ type: 'ObjectProperty', key: p.key?.name }),\n    ClassMethod: (p: any) => ({ type: 'ClassMethod', key: p.key?.name }),\n    AssignmentExpression: (p: any) => ({ type: 'AssignmentExpression', key: p.left?.name }),\n    ExportDefaultDeclaration: () => ({ type: 'ExportDefaultDeclaration', key: 'default' }),\n    ObjectMethod: (p: any) => ({ type: 'ObjectMethod', key: p.key?.name }),\n    ClassProperty: (p: any) => ({ type: 'ClassProperty', key: p.key?.name }),\n    JSXAttribute: (p: any) => ({ type: 'JSXAttribute', key: p.name?.name })\n  };\n\n  // Intentar obtener el nombre usando el mapeo\n  const mapping = nameMappings[parent.type as keyof typeof nameMappings];\n  if (mapping) {\n    return mapping(parent);\n  }\n\n  // Manejar ExportNamedDeclaration de forma especial\n  if (parent.type === 'ExportNamedDeclaration') {\n    const declaration = (parent as any).declaration;\n    if (declaration) {\n      if (declaration.type === 'VariableDeclaration') {\n        const firstDeclarator = declaration.declarations[0];\n        if (firstDeclarator?.id?.name) {\n          return { type: 'ExportNamedDeclaration', key: firstDeclarator.id.name };\n        }\n      } else if (declaration.id?.name) {\n        return { type: 'ExportNamedDeclaration', key: declaration.id.name };\n      }\n    }\n  }\n\n  // Manejar CallExpression de forma especial\n  if (parent.type === 'CallExpression') {\n    const callee = (parent as any).callee;\n    if (callee?.type === 'Identifier') {\n      return {\n        type: 'CallExpression',\n        key: callee.name,\n        method: callee.name,\n        value: `${callee.name} callback`\n      };\n    }\n    else if (callee?.type === 'MemberExpression' || callee?.type === 'OptionalMemberExpression') {\n      const methodName = callee.property?.name || 'unknown';\n      const objectName = callee.object?.name || 'object';\n      const isOptional = callee.type === 'OptionalMemberExpression';\n\n      return {\n        type: 'CallExpression',\n        key: objectName,\n        method: methodName,\n        isOptional,\n        value: `${methodName} callback`\n      };\n    }\n  }\n\n  return undefined;\n}\n\nexport function traverse(node: BabelNode, options: TraverseOptions, parent?: BabelNode) {\n  if (!node) return;\n\n  const namingSystem = new ContextualNamingSystem();\n\n  // Skip literals and other simple nodes\n  if (node.type === 'StringLiteral' || \n      node.type === 'NumericLiteral' || \n      node.type === 'BooleanLiteral' ||\n      node.type === 'NullLiteral' ||\n      node.type === 'RegExpLiteral') {\n    return;\n  }\n\n  // Handle functions\n  if (options.onFunction && (\n    node.type === 'FunctionDeclaration' ||\n    node.type === 'ArrowFunctionExpression' ||\n    node.type === 'FunctionExpression'\n  )) {\n    const parentInfo = getParentInfo(parent);\n    const context = namingSystem.extractContextFromNode(parent as BabelNode);\n    \n    if (context) {\n      namingSystem.pushContext(context);\n    }\n\n    let functionName = 'anonymous';\n\n    // Try to get function name from various sources\n    if (node.type === 'FunctionDeclaration' && (node as any).id?.name) {\n      functionName = (node as any).id.name;\n    } else if (parentInfo) {\n      if (parentInfo.type === 'CallExpression') {\n        functionName = parentInfo.value || `${parentInfo.method} callback`;\n      } else if (parentInfo.key) {\n        functionName = parentInfo.key;\n      }\n    } else if (context) {\n      functionName = namingSystem.generateName(node, parent);\n    }\n\n    // Force name on anonymous functions\n    if ((node.type === 'ArrowFunctionExpression' || node.type === 'FunctionExpression') && \n        functionName !== 'anonymous') {\n      (node as any).id = { type: 'Identifier', name: functionName };\n    }\n\n    options.onFunction(node as FunctionDeclaration | ArrowFunctionExpression | FunctionExpression, {\n      type: parent?.type || 'unknown',\n      key: parentInfo?.key || functionName,\n      method: context?.method,\n      isOptional: context?.isOptional,\n      value: functionName\n    });\n\n    if (context) {\n      namingSystem.popContext();\n    }\n  }\n\n  // Handle control flow\n  if (options.onControlFlow && (\n    node.type === 'IfStatement' ||\n    node.type === 'SwitchCase' ||\n    node.type === 'ForStatement' ||\n    node.type === 'WhileStatement' ||\n    node.type === 'DoWhileStatement' ||\n    node.type === 'CatchClause' ||\n    node.type === 'ConditionalExpression' ||\n    node.type === 'ForInStatement' ||\n    node.type === 'ForOfStatement' ||\n    node.type === 'LogicalExpression'\n  )) {\n    options.onControlFlow(node);\n  }\n\n  // Recursively traverse all properties that might contain nodes\n  Object.keys(node).forEach(key => {\n    const value = (node as any)[key];\n    \n    if (value && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        value.forEach(child => {\n          if (child && typeof child === 'object' && 'type' in child) {\n            traverse(child, options, node);\n          }\n        });\n      } else if ('type' in value) {\n        traverse(value, options, node);\n      }\n    }\n  });\n}\n\nexport function parseFile(content: string) {\n  return parse(content, {\n    sourceType: 'module',\n    plugins: [\n      'jsx',\n      'typescript',\n      'classProperties',\n      'decorators-legacy',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n      'dynamicImport',\n      'doExpressions',\n      'objectRestSpread',\n      'optionalCatchBinding',\n      'optionalChaining',\n      ['pipelineOperator', { proposal: 'minimal' }],\n      'throwExpressions',\n      'classPrivateProperties',\n      'classPrivateMethods',\n      'exportDefaultFrom',\n      'exportNamespaceFrom',\n      'partialApplication',\n      'recordAndTuple',\n      'throwExpressions',\n      'topLevelAwait'\n    ],\n    errorRecovery: true,\n    allowAwaitOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    allowUndeclaredExports: true,\n    ranges: true,\n    tokens: true\n  });\n} ","import * as fs from 'fs/promises';\r\nimport * as path from 'path';\r\nimport type { FileAnalysis, FunctionMetrics, FunctionAnalysis, AnalysisResult } from './types';\r\nimport type { \r\n  Node as BabelNode,\r\n  FunctionDeclaration, \r\n  ArrowFunctionExpression, \r\n  FunctionExpression,\r\n  VariableDeclarator,\r\n  ObjectProperty,\r\n  ClassMethod,\r\n  AssignmentExpression,\r\n  ExportDefaultDeclaration,\r\n  ExportNamedDeclaration,\r\n  ObjectMethod,\r\n  ClassProperty,\r\n  CallExpression,\r\n  JSXAttribute,\r\n  Identifier,\r\n  StringLiteral,\r\n  NumericLiteral,\r\n  MemberExpression\r\n} from '@babel/types';\r\nimport { parseFile, traverse } from './traverser';\r\n\r\ninterface ParentInfo {\r\n  type: string;\r\n  key?: string;\r\n  value?: string | number;\r\n  method?: string;\r\n  parent?: {\r\n    type: string;\r\n    callee?: {\r\n      name: string;\r\n    };\r\n  };\r\n}\r\n\r\nexport class CodeAnalyzer {\r\n  private readonly COMPLEXITY_THRESHOLD = 10;\r\n  private readonly LINES_THRESHOLD = 50;\r\n  private readonly SIMILARITY_THRESHOLD = 0.9; // Lower threshold to catch more potential duplications\r\n  private readonly MIN_CODE_LENGTH = 20; // Minimum characters to consider for duplication\r\n\r\n  private readonly FUNCTION_TYPES = {\r\n    METHOD: 'method' as const,\r\n    PROMISE: 'promise' as const,\r\n    ARRAY: 'array' as const,\r\n    HOOK: 'hook' as const,\r\n    CALLBACK: 'callback' as const,\r\n    FUNCTION: 'function' as const\r\n  } as const;\r\n\r\n  private complexityCache = new Map<string, number>();\r\n  private readonly MAX_CACHE_SIZE = 1000;\r\n\r\n  private generateCacheKey(node: BabelNode): string {\r\n    return `${node.type}-${node.loc?.start.line}-${node.loc?.start.column}`;\r\n  }\r\n\r\n  private async parseFile(filePath: string): Promise<BabelNode | null> {\r\n    try {\r\n      const content = await fs.readFile(filePath, 'utf-8');\r\n      return parseFile(content);\r\n    } catch (error) {\r\n      console.error(`Error parsing file ${filePath}:`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  private analyzeFunction(node: BabelNode, filePath: string): FunctionAnalysis | null {\r\n    if (!node || !('type' in node)) return null;\r\n\r\n    // Skip if not a function node\r\n    if (!['FunctionDeclaration', 'ArrowFunctionExpression', 'FunctionExpression'].includes(node.type)) {\r\n      return null;\r\n    }\r\n\r\n    const functionNode = node as FunctionDeclaration | ArrowFunctionExpression | FunctionExpression;\r\n    const functionName = (functionNode as any).id?.name || 'anonymous';\r\n    const functionSize = this.calculateFunctionSize(functionNode);\r\n    \r\n    // Calculate complexity by traversing the function body\r\n    let complexity = 1; // Base complexity\r\n    traverse(functionNode, {\r\n      onControlFlow: (node: BabelNode) => {\r\n        if (['IfStatement', 'SwitchCase', 'ForStatement', 'WhileStatement', \r\n             'DoWhileStatement', 'CatchClause', 'ConditionalExpression',\r\n             'ForInStatement', 'ForOfStatement', 'LogicalExpression'].includes(node.type)) {\r\n          complexity++;\r\n        }\r\n      }\r\n    });\r\n\r\n    // Analyze function characteristics\r\n    const characteristics = this.analyzeFunctionCharacteristics(functionNode);\r\n\r\n    return {\r\n      name: functionName,\r\n      type: this.determineFunctionType(functionNode),\r\n      size: functionSize,\r\n      complexity,\r\n      characteristics,\r\n      location: {\r\n        file: filePath,\r\n        start: functionNode.loc?.start,\r\n        end: functionNode.loc?.end\r\n      }\r\n    };\r\n  }\r\n\r\n  private analyzeFunctionCharacteristics(node: BabelNode): string[] {\r\n    const characteristics: string[] = [];\r\n    \r\n    // Analyze function properties\r\n    if (node.type === 'ArrowFunctionExpression') {\r\n      characteristics.push('arrow');\r\n    }\r\n    \r\n    if ((node as any).async) {\r\n      characteristics.push('async');\r\n    }\r\n    \r\n    if ((node as any).generator) {\r\n      characteristics.push('generator');\r\n    }\r\n\r\n    // Analyze function body\r\n    const body = (node as any).body;\r\n    if (body) {\r\n      // Check for common patterns\r\n      if (this.containsPattern(body, 'await')) {\r\n        characteristics.push('uses-await');\r\n      }\r\n      if (this.containsPattern(body, 'Promise')) {\r\n        characteristics.push('uses-promises');\r\n      }\r\n      if (this.containsPattern(body, 'useState') || this.containsPattern(body, 'useEffect')) {\r\n        characteristics.push('react-hook');\r\n      }\r\n      if (this.containsPattern(body, 'map') || this.containsPattern(body, 'filter')) {\r\n        characteristics.push('array-operation');\r\n      }\r\n    }\r\n\r\n    return characteristics;\r\n  }\r\n\r\n  private containsPattern(node: BabelNode, pattern: string): boolean {\r\n    let found = false;\r\n    traverse(node, {\r\n      onControlFlow: (node: BabelNode) => {\r\n        if (node.type === 'Identifier' && (node as Identifier).name.includes(pattern)) {\r\n          found = true;\r\n        }\r\n      }\r\n    });\r\n    return found;\r\n  }\r\n\r\n  private determineFunctionType(node: BabelNode): string {\r\n    const characteristics = this.analyzeFunctionCharacteristics(node);\r\n    \r\n    // Determine type based on characteristics and context\r\n    if (characteristics.includes('react-hook')) {\r\n      return 'react-hook';\r\n    }\r\n    if (characteristics.includes('async') || characteristics.includes('uses-promises')) {\r\n      return 'async';\r\n    }\r\n    if (characteristics.includes('generator')) {\r\n      return 'generator';\r\n    }\r\n    if (characteristics.includes('arrow')) {\r\n      return 'arrow';\r\n    }\r\n    \r\n    return 'regular';\r\n  }\r\n\r\n  private calculateFunctionSize(node: BabelNode): number {\r\n    if (!node.loc) return 0;\r\n    return node.loc.end.line - node.loc.start.line + 1;\r\n  }\r\n\r\n  private calculateComplexity(node: BabelNode): number {\r\n    const cacheKey = this.generateCacheKey(node);\r\n    if (this.complexityCache.has(cacheKey)) {\r\n      return this.complexityCache.get(cacheKey)!;\r\n    }\r\n\r\n    let complexity = 1;\r\n\r\n    traverse(node, {\r\n      onControlFlow: (node: BabelNode) => {\r\n        if (['IfStatement', 'SwitchCase', 'ForStatement', 'WhileStatement', \r\n             'DoWhileStatement', 'CatchClause', 'ConditionalExpression',\r\n             'ForInStatement', 'ForOfStatement', 'LogicalExpression'].includes(node.type)) {\r\n          complexity++;\r\n        }\r\n      }\r\n    });\r\n\r\n    if (this.complexityCache.size >= this.MAX_CACHE_SIZE) {\r\n      this.complexityCache.clear();\r\n    }\r\n    this.complexityCache.set(cacheKey, complexity);\r\n    return complexity;\r\n  }\r\n\r\n  private normalizeCode(code: string): string {\r\n    // Remove HTML tags and normalize whitespace\r\n    return code\r\n      .replace(/<[^>]*>/g, '') // Remove HTML tags\r\n      .replace(/\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*/g, '') // Remove comments\r\n      .replace(/\\s+/g, ' ') // Normalize whitespace\r\n      .trim();\r\n  }\r\n\r\n  private findDuplicatedCode(functions: FunctionMetrics[]): number {\r\n    // Get all lines from all functions\r\n    const allLines = functions.flatMap(f => {\r\n      if (!f.code) return [];\r\n      return f.code.split('\\n')\r\n        .map(line => this.normalizeCode(line))\r\n        .filter(line => line.length > 5); // Only keep lines with more than 5 characters\r\n    });\r\n\r\n    // Count occurrences of each line\r\n    const lineCounts = new Map<string, number>();\r\n    allLines.forEach(line => {\r\n      lineCounts.set(line, (lineCounts.get(line) || 0) + 1);\r\n    });\r\n\r\n    // Count duplicated lines (lines that appear more than once)\r\n    let duplicatedLines = 0;\r\n    lineCounts.forEach((count, line) => {\r\n      if (count > 1) {\r\n        duplicatedLines += count - 1; // Count only the duplicates, not the original\r\n      }\r\n    });\r\n\r\n    return duplicatedLines;\r\n  }\r\n\r\n  async analyzeRepo(repoPath: string): Promise<AnalysisResult> {\r\n    const files = await this.findFiles(repoPath);\r\n    const functions: FunctionAnalysis[] = [];\r\n    const fileAnalyses: FileAnalysis[] = [];\r\n\r\n    for (const file of files) {\r\n      try {\r\n        const fileAnalysis = await this.analyzeFile(file);\r\n        if (fileAnalysis) {\r\n          fileAnalyses.push(fileAnalysis);\r\n          functions.push(...fileAnalysis.functions.map(f => ({\r\n            name: f.name,\r\n            type: f.type,\r\n            size: f.lines,\r\n            complexity: f.complexity,\r\n            characteristics: [],\r\n            location: {\r\n              file: fileAnalysis.path,\r\n              start: { line: f.startLine, column: 0 },\r\n              end: { line: f.startLine + f.lines, column: 0 }\r\n            }\r\n          })));\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error analyzing file ${file}:`, error);\r\n      }\r\n    }\r\n\r\n    return {\r\n      functions,\r\n      files: fileAnalyses,\r\n      summary: {\r\n        totalFiles: fileAnalyses.length,\r\n        totalLines: fileAnalyses.reduce((sum, file) => sum + file.totalLines, 0),\r\n        totalFunctions: functions.length,\r\n        errorCount: 0,\r\n        functionsOver50Lines: functions.filter(f => f.size > this.LINES_THRESHOLD).length,\r\n        functionsOverComplexity10: functions.filter(f => f.complexity > 10).length,\r\n        averageComplexity: functions.reduce((sum, f) => sum + f.complexity, 0) / functions.length || 0,\r\n        averageDuplication: fileAnalyses.reduce((sum, file) => sum + file.duplicationPercentage, 0) / fileAnalyses.length || 0\r\n      }\r\n    };\r\n  }\r\n\r\n  private async findFiles(repoPath: string): Promise<string[]> {\r\n    const files: string[] = [];\r\n    const processDirectory = async (dirPath: string) => {\r\n      try {\r\n        const entries = await fs.readdir(dirPath, { withFileTypes: true });\r\n        \r\n        for (const entry of entries) {\r\n          const fullPath = path.join(dirPath, entry.name);\r\n          \r\n          if (entry.isDirectory()) {\r\n            if (!entry.name.startsWith('.') && entry.name !== 'node_modules') {\r\n              await processDirectory(fullPath);\r\n            }\r\n          } else if (entry.isFile()) {\r\n            const ext = path.extname(entry.name).toLowerCase();\r\n            if (['.js', '.jsx', '.ts', '.tsx'].includes(ext)) {\r\n              files.push(fullPath);\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error processing directory ${dirPath}:`, error);\r\n      }\r\n    };\r\n\r\n    await processDirectory(repoPath);\r\n    return files;\r\n  }\r\n\r\n  public async analyzeFile(filePath: string): Promise<FileAnalysis | null> {\r\n    try {\r\n      const ast = await this.parseFile(filePath);\r\n      if (!ast) return null;\r\n\r\n      const fileContent = await fs.readFile(filePath, 'utf-8');\r\n      const lines = fileContent.split('\\n');\r\n      const functions: FunctionMetrics[] = [];\r\n\r\n      traverse(ast, {\r\n        onFunction: (node: FunctionDeclaration | ArrowFunctionExpression | FunctionExpression) => {\r\n          const analysis = this.analyzeFunction(node, filePath);\r\n          if (analysis) {\r\n            const startLine = analysis.location.start?.line || 0;\r\n            const endLine = analysis.location.end?.line || 0;\r\n            const functionCode = lines.slice(startLine - 1, endLine).join('\\n');\r\n            \r\n            functions.push({\r\n              name: analysis.name,\r\n              lines: analysis.size,\r\n              startLine: startLine,\r\n              complexity: analysis.complexity,\r\n              type: analysis.type as any,\r\n              hasWarning: analysis.size > this.LINES_THRESHOLD || analysis.complexity > this.COMPLEXITY_THRESHOLD,\r\n              code: functionCode\r\n            });\r\n          }\r\n        }\r\n      });\r\n\r\n      const stats = await fs.stat(filePath);\r\n      const totalLines = functions.reduce((sum, f) => sum + f.lines, 0);\r\n      const duplicatedLines = this.findDuplicatedCode(functions);\r\n\r\n      return {\r\n        path: filePath,\r\n        name: path.basename(filePath),\r\n        extension: path.extname(filePath),\r\n        totalLines: lines.length,\r\n        functions,\r\n        functionsCount: functions.length,\r\n        complexity: functions.reduce((sum, f) => sum + f.complexity, 0) / functions.length || 0,\r\n        maxComplexity: Math.max(...functions.map(f => f.complexity), 0),\r\n        duplicationPercentage: totalLines > 0 ? (duplicatedLines / totalLines) * 100 : 0,\r\n        warningCount: functions.filter(f => f.hasWarning).length,\r\n        fileSize: stats.size\r\n      };\r\n    } catch (error) {\r\n      console.error(`Error analyzing file ${filePath}:`, error);\r\n      return null;\r\n    }\r\n  }\r\n} "],"mappings":"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","names":["node"]}