{"version":3,"sources":["../src/analyzer.ts","../src/traverser.ts"],"sourcesContent":["import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport type { FileAnalysis, FunctionMetrics, FunctionAnalysis, AnalysisResult } from './types';\nimport type { \n  Node as BabelNode,\n  FunctionDeclaration, \n  ArrowFunctionExpression, \n  FunctionExpression,\n  VariableDeclarator,\n  ObjectProperty,\n  ClassMethod,\n  AssignmentExpression,\n  ExportDefaultDeclaration,\n  ExportNamedDeclaration,\n  ObjectMethod,\n  ClassProperty,\n  CallExpression,\n  JSXAttribute,\n  Identifier,\n  StringLiteral,\n  NumericLiteral,\n  MemberExpression\n} from '@babel/types';\nimport { parseFile, traverse } from './traverser';\n\ninterface ParentInfo {\n  type: string;\n  key?: string;\n  value?: string | number;\n  method?: string;\n  parent?: {\n    type: string;\n    callee?: {\n      name: string;\n    };\n  };\n}\n\ninterface NodeInfo {\n  type: string;\n  key?: string;\n  method?: string;\n  isOptional?: boolean;\n  value?: string;\n}\n\ninterface TraverseOptions {\n  onFunction?: (node: FunctionDeclaration | ArrowFunctionExpression | FunctionExpression, parent?: NodeInfo) => void;\n  onControlFlow?: (node: BabelNode) => void;\n}\n\nexport class CodeAnalyzer {\n  private readonly ARRAY_METHODS = ['map', 'filter', 'forEach', 'find', 'some', 'every', 'reduce'] as const;\n  private readonly PROMISE_METHODS = ['then', 'catch', 'finally'] as const;\n  private readonly REACT_HOOKS = ['useEffect', 'useCallback', 'useMemo', 'useState', 'useRef', 'useContext'] as const;\n  private readonly COMPLEXITY_THRESHOLD = 10;\n  private readonly LINES_THRESHOLD = 50;\n  private readonly DUPLICATION_THRESHOLD = 0.8;\n  private readonly CACHE_SIZE = 1000;\n\n  private readonly FUNCTION_TYPES = {\n    METHOD: 'method' as const,\n    PROMISE: 'promise' as const,\n    ARRAY: 'array' as const,\n    HOOK: 'hook' as const,\n    CALLBACK: 'callback' as const,\n    FUNCTION: 'function' as const\n  } as const;\n\n  private complexityCache = new Map<string, number>();\n  private fanInCache = new Map<string, number>();\n  private fanOutCache = new Map<string, number>();\n  private readonly MAX_CACHE_SIZE = 1000;\n\n  private clearCaches() {\n    this.complexityCache.clear();\n    this.fanInCache.clear();\n    this.fanOutCache.clear();\n  }\n\n  private generateCacheKey(node: BabelNode): string {\n    return `${node.type}-${node.loc?.start.line}-${node.loc?.start.column}`;\n  }\n\n  private async parseFile(filePath: string): Promise<BabelNode | null> {\n    try {\n      const content = await fs.readFile(filePath, 'utf-8');\n      return parseFile(content);\n    } catch (error) {\n      console.error(`Error parsing file ${filePath}:`, error);\n      return null;\n    }\n  }\n\n  private analyzeFunction(node: BabelNode, filePath: string): FunctionAnalysis | null {\n    if (!node || !('type' in node)) return null;\n\n    // Skip if not a function node\n    if (!['FunctionDeclaration', 'ArrowFunctionExpression', 'FunctionExpression'].includes(node.type)) {\n      return null;\n    }\n\n    const functionNode = node as FunctionDeclaration | ArrowFunctionExpression | FunctionExpression;\n    const functionName = (functionNode as any).id?.name || 'anonymous';\n    const functionSize = this.calculateFunctionSize(functionNode);\n    const complexity = this.calculateComplexity(functionNode);\n    const fanIn = this.calculateFanIn(functionNode, filePath);\n    const fanOut = this.calculateFanOut(functionNode, filePath);\n\n    // Analyze function characteristics\n    const characteristics = this.analyzeFunctionCharacteristics(functionNode);\n\n    return {\n      name: functionName,\n      type: this.determineFunctionType(functionNode),\n      size: functionSize,\n      complexity,\n      fanIn,\n      fanOut,\n      characteristics,\n      location: {\n        file: filePath,\n        start: functionNode.loc?.start,\n        end: functionNode.loc?.end\n      }\n    };\n  }\n\n  private analyzeFunctionCharacteristics(node: BabelNode): string[] {\n    const characteristics: string[] = [];\n    \n    // Analyze function properties\n    if (node.type === 'ArrowFunctionExpression') {\n      characteristics.push('arrow');\n    }\n    \n    if ((node as any).async) {\n      characteristics.push('async');\n    }\n    \n    if ((node as any).generator) {\n      characteristics.push('generator');\n    }\n\n    // Analyze function body\n    const body = (node as any).body;\n    if (body) {\n      // Check for common patterns\n      if (this.containsPattern(body, 'await')) {\n        characteristics.push('uses-await');\n      }\n      if (this.containsPattern(body, 'Promise')) {\n        characteristics.push('uses-promises');\n      }\n      if (this.containsPattern(body, 'useState') || this.containsPattern(body, 'useEffect')) {\n        characteristics.push('react-hook');\n      }\n      if (this.containsPattern(body, 'map') || this.containsPattern(body, 'filter')) {\n        characteristics.push('array-operation');\n      }\n    }\n\n    return characteristics;\n  }\n\n  private containsPattern(node: BabelNode, pattern: string): boolean {\n    let found = false;\n    traverse(node, {\n      onControlFlow: (node: BabelNode) => {\n        if (node.type === 'Identifier' && (node as Identifier).name.includes(pattern)) {\n          found = true;\n        }\n      }\n    });\n    return found;\n  }\n\n  private determineFunctionType(node: BabelNode): string {\n    const characteristics = this.analyzeFunctionCharacteristics(node);\n    \n    // Determine type based on characteristics and context\n    if (characteristics.includes('react-hook')) {\n      return 'react-hook';\n    }\n    if (characteristics.includes('async') || characteristics.includes('uses-promises')) {\n      return 'async';\n    }\n    if (characteristics.includes('generator')) {\n      return 'generator';\n    }\n    if (characteristics.includes('arrow')) {\n      return 'arrow';\n    }\n    \n    return 'regular';\n  }\n\n  private calculateFunctionSize(node: BabelNode): number {\n    if (!node.loc) return 0;\n    return node.loc.end.line - node.loc.start.line + 1;\n  }\n\n  private calculateComplexity(node: BabelNode): number {\n    const cacheKey = this.generateCacheKey(node);\n    if (this.complexityCache.has(cacheKey)) {\n      return this.complexityCache.get(cacheKey)!;\n    }\n\n    let complexity = 1;\n\n    traverse(node, {\n      onControlFlow: (node: BabelNode) => {\n        if (['IfStatement', 'SwitchCase', 'ForStatement', 'WhileStatement', \n             'DoWhileStatement', 'CatchClause', 'ConditionalExpression'].includes(node.type)) {\n          complexity++;\n        }\n      }\n    });\n\n    if (this.complexityCache.size >= this.MAX_CACHE_SIZE) {\n      this.complexityCache.clear();\n    }\n    this.complexityCache.set(cacheKey, complexity);\n    return complexity;\n  }\n\n  private calculateFanIn(node: BabelNode, filePath: string): number {\n    const cacheKey = this.generateCacheKey(node);\n    if (this.fanInCache.has(cacheKey)) {\n      return this.fanInCache.get(cacheKey)!;\n    }\n\n    let fanIn = 0;\n    const functionName = (node as any).id?.name;\n\n    if (functionName) {\n      traverse(node, {\n        onControlFlow: (node: BabelNode) => {\n          if (node.type === 'Identifier' && (node as Identifier).name === functionName) {\n            fanIn++;\n          }\n        }\n      });\n    }\n\n    if (this.fanInCache.size >= this.MAX_CACHE_SIZE) {\n      this.fanInCache.clear();\n    }\n    this.fanInCache.set(cacheKey, fanIn);\n    return fanIn;\n  }\n\n  private calculateFanOut(node: BabelNode, filePath: string): number {\n    const cacheKey = this.generateCacheKey(node);\n    if (this.fanOutCache.has(cacheKey)) {\n      return this.fanOutCache.get(cacheKey)!;\n    }\n\n    let fanOut = 0;\n    traverse(node, {\n      onControlFlow: (node: BabelNode) => {\n        if (node.type === 'CallExpression') {\n          fanOut++;\n        }\n      }\n    });\n\n    if (this.fanOutCache.size >= this.MAX_CACHE_SIZE) {\n      this.fanOutCache.clear();\n    }\n    this.fanOutCache.set(cacheKey, fanOut);\n    return fanOut;\n  }\n\n  async analyzeRepo(repoPath: string): Promise<AnalysisResult> {\n    const files = await this.findFiles(repoPath);\n    const functions: FunctionAnalysis[] = [];\n    const fileAnalyses: FileAnalysis[] = [];\n\n    for (const file of files) {\n      try {\n        const fileAnalysis = await this.analyzeFile(file);\n        if (fileAnalysis) {\n          fileAnalyses.push(fileAnalysis);\n          functions.push(...fileAnalysis.functions.map(f => ({\n            name: f.name,\n            type: f.type,\n            size: f.lines,\n            complexity: f.complexity,\n            fanIn: f.fanIn,\n            fanOut: f.fanOut,\n            characteristics: [],\n            location: {\n              file: fileAnalysis.path,\n              start: { line: f.startLine, column: 0 },\n              end: { line: f.startLine + f.lines, column: 0 }\n            }\n          })));\n        }\n      } catch (error) {\n        console.error(`Error analyzing file ${file}:`, error);\n      }\n    }\n\n    return {\n      functions,\n      files: fileAnalyses,\n      summary: {\n        totalFiles: fileAnalyses.length,\n        totalLines: fileAnalyses.reduce((sum, file) => sum + file.totalLines, 0),\n        totalFunctions: functions.length,\n        errorCount: 0,\n        functionsOver50Lines: functions.filter(f => f.size > 50).length,\n        functionsOverComplexity10: functions.filter(f => f.complexity > 10).length,\n        averageComplexity: functions.reduce((sum, f) => sum + f.complexity, 0) / functions.length || 0,\n        averageDuplication: fileAnalyses.reduce((sum, file) => sum + file.duplicationPercentage, 0) / fileAnalyses.length || 0\n      }\n    };\n  }\n\n  private async findFiles(repoPath: string): Promise<string[]> {\n    const files: string[] = [];\n    const processDirectory = async (dirPath: string) => {\n      try {\n        const entries = await fs.readdir(dirPath, { withFileTypes: true });\n        \n        for (const entry of entries) {\n          const fullPath = path.join(dirPath, entry.name);\n          \n          if (entry.isDirectory()) {\n            if (!entry.name.startsWith('.') && entry.name !== 'node_modules') {\n              await processDirectory(fullPath);\n            }\n          } else if (entry.isFile()) {\n            const ext = path.extname(entry.name).toLowerCase();\n            if (['.js', '.jsx', '.ts', '.tsx'].includes(ext)) {\n              files.push(fullPath);\n            }\n          }\n        }\n      } catch (error) {\n        console.error(`Error processing directory ${dirPath}:`, error);\n      }\n    };\n\n    await processDirectory(repoPath);\n    return files;\n  }\n\n  private async analyzeFile(filePath: string): Promise<FileAnalysis | null> {\n    try {\n      const ast = await this.parseFile(filePath);\n      if (!ast) return null;\n\n      const fileContent = await fs.readFile(filePath, 'utf-8');\n      const lines = fileContent.split('\\n').filter((line: string) => line.trim().length > 0).length;\n      const functions: FunctionMetrics[] = [];\n\n      traverse(ast, {\n        onFunction: (node: FunctionDeclaration | ArrowFunctionExpression | FunctionExpression) => {\n          const analysis = this.analyzeFunction(node, filePath);\n          if (analysis) {\n            functions.push({\n              name: analysis.name,\n              lines: analysis.size,\n              startLine: analysis.location.start?.line || 0,\n              complexity: analysis.complexity,\n              fanIn: analysis.fanIn,\n              fanOut: analysis.fanOut,\n              type: analysis.type as any,\n              hasWarning: analysis.size > 50 || analysis.complexity > 10\n            });\n          }\n        }\n      });\n\n      const stats = await fs.stat(filePath);\n\n      return {\n        path: filePath,\n        name: path.basename(filePath),\n        extension: path.extname(filePath),\n        totalLines: lines,\n        functions,\n        functionsCount: functions.length,\n        complexity: functions.reduce((sum, f) => sum + f.complexity, 0) / functions.length || 0,\n        maxComplexity: Math.max(...functions.map(f => f.complexity), 0),\n        averageFanIn: functions.reduce((sum, f) => sum + f.fanIn, 0) / functions.length || 0,\n        averageFanOut: functions.reduce((sum, f) => sum + f.fanOut, 0) / functions.length || 0,\n        duplicationPercentage: functions.filter(f => f.fanIn > 1).length / functions.length * 100 || 0,\n        warningCount: functions.filter(f => f.hasWarning).length,\n        fileSize: stats.size\n      };\n    } catch (error) {\n      console.error(`Error analyzing file ${filePath}:`, error);\n      return null;\n    }\n  }\n} ","import { parse } from '@babel/parser';\r\nimport type { \r\n  Node as BabelNode, \r\n  FunctionDeclaration, \r\n  ArrowFunctionExpression,\r\n  FunctionExpression,\r\n  IfStatement, \r\n  SwitchCase, \r\n  ForStatement, \r\n  WhileStatement, \r\n  DoWhileStatement, \r\n  CatchClause, \r\n  ConditionalExpression,\r\n  VariableDeclarator,\r\n  ObjectProperty,\r\n  ClassMethod,\r\n  AssignmentExpression,\r\n  ExportDefaultDeclaration,\r\n  ExportNamedDeclaration,\r\n  ObjectMethod,\r\n  ClassProperty,\r\n  CallExpression,\r\n  JSXAttribute,\r\n  MemberExpression\r\n} from '@babel/types';\r\n\r\ninterface FunctionContext {\r\n  type: string;\r\n  objectName?: string;\r\n  method?: string;\r\n  isOptional?: boolean;\r\n  parent?: FunctionContext;\r\n  loc?: {\r\n    start: { line: number; column: number };\r\n    end: { line: number; column: number };\r\n  } | null;\r\n}\r\n\r\nclass ContextualNamingSystem {\r\n  private contextStack: FunctionContext[] = [];\r\n  private namedFunctions: Map<string, string> = new Map();\r\n  private readonly CACHE_KEY_SEPARATOR = '::';\r\n\r\n  // Mapeo estático de tipos de contexto a nombres de función\r\n  private static readonly CONTEXT_NAME_MAPPINGS: Record<string, (ctx: FunctionContext) => string> = {\r\n    OptionalCallExpression: (ctx) => `${ctx.objectName}?.${ctx.method} callback`,\r\n    CallExpression: (ctx) => {\r\n      if (!ctx.method) return 'anonymous';\r\n      \r\n      // Detectar tipos específicos de callbacks\r\n      if (['then', 'catch', 'finally'].includes(ctx.method)) {\r\n        return `${ctx.method} handler`;\r\n      }\r\n      if (['map', 'filter', 'forEach', 'find', 'some', 'every', 'reduce'].includes(ctx.method)) {\r\n        return `${ctx.method} callback`;\r\n      }\r\n      if (ctx.method.startsWith('use')) {\r\n        return `${ctx.method} callback`;\r\n      }\r\n      return `${ctx.objectName}.${ctx.method} callback`;\r\n    },\r\n    JSXExpressionContainer: (ctx) => `${ctx.objectName}.${ctx.method} callback`\r\n  };\r\n\r\n  // Mapeo estático de tipos de nodo a extractores de contexto\r\n  private static readonly CONTEXT_EXTRACTORS: Record<string, (node: BabelNode) => FunctionContext | null> = {\r\n    OptionalCallExpression: (node) => {\r\n      const callee = (node as any).callee;\r\n      if (callee?.type === 'OptionalMemberExpression') {\r\n        return {\r\n          type: 'OptionalCallExpression',\r\n          objectName: callee.object?.name || 'object',\r\n          method: callee.property?.name,\r\n          isOptional: true,\r\n          loc: node.loc\r\n        };\r\n      }\r\n      return null;\r\n    },\r\n    CallExpression: (node) => {\r\n      const callee = (node as any).callee;\r\n      if (callee?.type === 'MemberExpression') {\r\n        return {\r\n          type: 'CallExpression',\r\n          objectName: callee.object?.name || 'object',\r\n          method: callee.property?.name,\r\n          loc: node.loc\r\n        };\r\n      }\r\n      return null;\r\n    },\r\n    JSXExpressionContainer: (node) => {\r\n      const expression = (node as any).expression;\r\n      if (expression?.type === 'CallExpression') {\r\n        const callee = expression.callee;\r\n        if (callee?.type === 'MemberExpression') {\r\n          return {\r\n            type: 'JSXExpressionContainer',\r\n            objectName: callee.object?.name || 'object',\r\n            method: callee.property?.name,\r\n            loc: node.loc\r\n          };\r\n        }\r\n      }\r\n      return null;\r\n    }\r\n  };\r\n\r\n  private generateCacheKey(node: BabelNode, context?: FunctionContext): string {\r\n    return `${node.type}-${node.loc?.start.line}-${node.loc?.start.column}${this.CACHE_KEY_SEPARATOR}${context?.type || 'no-context'}`;\r\n  }\r\n\r\n  public pushContext(context: FunctionContext) {\r\n    if (this.contextStack.length > 0) {\r\n      context.parent = this.contextStack[this.contextStack.length - 1];\r\n    }\r\n    this.contextStack.push(context);\r\n  }\r\n\r\n  public popContext() {\r\n    this.contextStack.pop();\r\n  }\r\n\r\n  private getCurrentContext(): FunctionContext | undefined {\r\n    return this.contextStack[this.contextStack.length - 1];\r\n  }\r\n\r\n  public generateName(node: BabelNode, parent?: BabelNode): string {\r\n    const currentContext = this.getCurrentContext();\r\n    \r\n    // Intentar obtener el nombre del caché\r\n    const cacheKey = this.generateCacheKey(node, currentContext);\r\n    const cachedName = this.namedFunctions.get(cacheKey);\r\n    if (cachedName) {\r\n      return cachedName;\r\n    }\r\n    \r\n    if (!currentContext) {\r\n      return 'anonymous';\r\n    }\r\n\r\n    // Intentar obtener el nombre usando el mapeo estático\r\n    const mapping = ContextualNamingSystem.CONTEXT_NAME_MAPPINGS[currentContext.type];\r\n    let name = 'anonymous';\r\n    \r\n    if (mapping) {\r\n      name = mapping(currentContext);\r\n    } else if (node.type === 'FunctionDeclaration' && (node as any).id?.name) {\r\n      name = (node as any).id.name;\r\n    }\r\n\r\n    // Guardar en el caché\r\n    this.namedFunctions.set(cacheKey, name);\r\n    return name;\r\n  }\r\n\r\n  public extractContextFromNode(node: BabelNode): FunctionContext | null {\r\n    const extractor = ContextualNamingSystem.CONTEXT_EXTRACTORS[node.type as keyof typeof ContextualNamingSystem.CONTEXT_EXTRACTORS];\r\n    return extractor ? extractor(node) : null;\r\n  }\r\n}\r\n\r\ninterface NodeInfo {\r\n  node: BabelNode;\r\n  parent?: {\r\n    type: string;\r\n    key?: string;\r\n    value?: string;\r\n    method?: string;\r\n    isOptional?: boolean;\r\n  };\r\n}\r\n\r\nexport interface TraverseOptions {\r\n  onFunction?: (node: FunctionDeclaration | ArrowFunctionExpression | FunctionExpression, parent?: NodeInfo['parent']) => void;\r\n  onControlFlow?: (node: BabelNode) => void;\r\n}\r\n\r\nfunction getParentInfo(parent: BabelNode | undefined): NodeInfo['parent'] {\r\n  if (!parent) return undefined;\r\n\r\n  // Mapeo de tipos de nodo a sus propiedades de nombre\r\n  const nameMappings = {\r\n    VariableDeclarator: (p: any) => ({ type: 'VariableDeclarator', key: p.id?.name }),\r\n    ObjectProperty: (p: any) => ({ type: 'ObjectProperty', key: p.key?.name }),\r\n    ClassMethod: (p: any) => ({ type: 'ClassMethod', key: p.key?.name }),\r\n    AssignmentExpression: (p: any) => ({ type: 'AssignmentExpression', key: p.left?.name }),\r\n    ExportDefaultDeclaration: () => ({ type: 'ExportDefaultDeclaration', key: 'default' }),\r\n    ObjectMethod: (p: any) => ({ type: 'ObjectMethod', key: p.key?.name }),\r\n    ClassProperty: (p: any) => ({ type: 'ClassProperty', key: p.key?.name }),\r\n    JSXAttribute: (p: any) => ({ type: 'JSXAttribute', key: p.name?.name })\r\n  };\r\n\r\n  // Intentar obtener el nombre usando el mapeo\r\n  const mapping = nameMappings[parent.type as keyof typeof nameMappings];\r\n  if (mapping) {\r\n    return mapping(parent);\r\n  }\r\n\r\n  // Manejar ExportNamedDeclaration de forma especial\r\n  if (parent.type === 'ExportNamedDeclaration') {\r\n    const declaration = (parent as any).declaration;\r\n    if (declaration) {\r\n      if (declaration.type === 'VariableDeclaration') {\r\n        const firstDeclarator = declaration.declarations[0];\r\n        if (firstDeclarator?.id?.name) {\r\n          return { type: 'ExportNamedDeclaration', key: firstDeclarator.id.name };\r\n        }\r\n      } else if (declaration.id?.name) {\r\n        return { type: 'ExportNamedDeclaration', key: declaration.id.name };\r\n      }\r\n    }\r\n  }\r\n\r\n  // Manejar CallExpression de forma especial\r\n  if (parent.type === 'CallExpression') {\r\n    const callee = (parent as any).callee;\r\n    if (callee?.type === 'Identifier') {\r\n      return {\r\n        type: 'CallExpression',\r\n        key: callee.name,\r\n        method: callee.name,\r\n        value: `${callee.name} callback`\r\n      };\r\n    }\r\n    else if (callee?.type === 'MemberExpression' || callee?.type === 'OptionalMemberExpression') {\r\n      const methodName = callee.property?.name || 'unknown';\r\n      const objectName = callee.object?.name || 'object';\r\n      const isOptional = callee.type === 'OptionalMemberExpression';\r\n\r\n      return {\r\n        type: 'CallExpression',\r\n        key: objectName,\r\n        method: methodName,\r\n        isOptional,\r\n        value: `${methodName} callback`\r\n      };\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\nexport function traverse(node: BabelNode, options: TraverseOptions, parent?: BabelNode) {\r\n  if (!node) return;\r\n\r\n  const namingSystem = new ContextualNamingSystem();\r\n\r\n  // Skip literals and other simple nodes\r\n  if (node.type === 'StringLiteral' || \r\n      node.type === 'NumericLiteral' || \r\n      node.type === 'BooleanLiteral' ||\r\n      node.type === 'NullLiteral' ||\r\n      node.type === 'RegExpLiteral') {\r\n    return;\r\n  }\r\n\r\n  // Handle functions\r\n  if (options.onFunction && (\r\n    node.type === 'FunctionDeclaration' ||\r\n    node.type === 'ArrowFunctionExpression' ||\r\n    node.type === 'FunctionExpression'\r\n  )) {\r\n    const parentInfo = getParentInfo(parent);\r\n    const context = namingSystem.extractContextFromNode(parent as BabelNode);\r\n    \r\n    if (context) {\r\n      namingSystem.pushContext(context);\r\n    }\r\n\r\n    let functionName = 'anonymous';\r\n\r\n    // Try to get function name from various sources\r\n    if (node.type === 'FunctionDeclaration' && (node as any).id?.name) {\r\n      functionName = (node as any).id.name;\r\n    } else if (parentInfo) {\r\n      if (parentInfo.type === 'CallExpression') {\r\n        functionName = parentInfo.value || `${parentInfo.method} callback`;\r\n      } else if (parentInfo.key) {\r\n        functionName = parentInfo.key;\r\n      }\r\n    } else if (context) {\r\n      functionName = namingSystem.generateName(node, parent);\r\n    }\r\n\r\n    // Force name on anonymous functions\r\n    if ((node.type === 'ArrowFunctionExpression' || node.type === 'FunctionExpression') && \r\n        functionName !== 'anonymous') {\r\n      (node as any).id = { type: 'Identifier', name: functionName };\r\n    }\r\n\r\n    options.onFunction(node as FunctionDeclaration | ArrowFunctionExpression | FunctionExpression, {\r\n      type: parent?.type || 'unknown',\r\n      key: parentInfo?.key || functionName,\r\n      method: context?.method,\r\n      isOptional: context?.isOptional,\r\n      value: functionName\r\n    });\r\n\r\n    if (context) {\r\n      namingSystem.popContext();\r\n    }\r\n  }\r\n\r\n  // Handle control flow\r\n  if (options.onControlFlow && (\r\n    node.type === 'IfStatement' ||\r\n    node.type === 'SwitchCase' ||\r\n    node.type === 'ForStatement' ||\r\n    node.type === 'WhileStatement' ||\r\n    node.type === 'DoWhileStatement' ||\r\n    node.type === 'CatchClause' ||\r\n    node.type === 'ConditionalExpression'\r\n  )) {\r\n    options.onControlFlow(node);\r\n  }\r\n\r\n  // Recursively traverse all properties that might contain nodes\r\n  Object.keys(node).forEach(key => {\r\n    const value = (node as any)[key];\r\n    \r\n    if (value && typeof value === 'object') {\r\n      if (Array.isArray(value)) {\r\n        value.forEach(child => {\r\n          if (child && typeof child === 'object' && 'type' in child) {\r\n            traverse(child, options, node);\r\n          }\r\n        });\r\n      } else if ('type' in value) {\r\n        traverse(value, options, node);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nfunction getChildren(node: BabelNode): BabelNode[] {\r\n  const children: BabelNode[] = [];\r\n  \r\n  // Map node types to their child properties\r\n  const childProperties: Record<string, string[]> = {\r\n    Program: ['body'],\r\n    BlockStatement: ['body'],\r\n    FunctionDeclaration: ['body', 'params'],\r\n    ArrowFunctionExpression: ['body', 'params'],\r\n    FunctionExpression: ['body', 'params'],\r\n    IfStatement: ['consequent', 'alternate'],\r\n    SwitchCase: ['consequent'],\r\n    ForStatement: ['init', 'test', 'update', 'body'],\r\n    WhileStatement: ['test', 'body'],\r\n    DoWhileStatement: ['body', 'test'],\r\n    TryStatement: ['block', 'handler', 'finalizer'],\r\n    CatchClause: ['body'],\r\n    ConditionalExpression: ['test', 'consequent', 'alternate'],\r\n    CallExpression: ['arguments', 'callee'],\r\n    MemberExpression: ['object', 'property'],\r\n    ObjectExpression: ['properties'],\r\n    ArrayExpression: ['elements'],\r\n    JSXElement: ['openingElement', 'closingElement', 'children'],\r\n    JSXExpressionContainer: ['expression'],\r\n    VariableDeclaration: ['declarations'],\r\n    VariableDeclarator: ['init'],\r\n    ObjectProperty: ['value'],\r\n    ClassMethod: ['body', 'params'],\r\n    ClassProperty: ['value'],\r\n    ExportDefaultDeclaration: ['declaration'],\r\n    ExportNamedDeclaration: ['declaration'],\r\n    ClassDeclaration: ['body', 'superClass'],\r\n    ClassBody: ['body'],\r\n    MethodDefinition: ['value', 'key'],\r\n    Property: ['value', 'key'],\r\n    AssignmentExpression: ['left', 'right'],\r\n    BinaryExpression: ['left', 'right'],\r\n    LogicalExpression: ['left', 'right'],\r\n    UnaryExpression: ['argument'],\r\n    UpdateExpression: ['argument'],\r\n    NewExpression: ['arguments', 'callee'],\r\n    TaggedTemplateExpression: ['tag', 'quasi'],\r\n    TemplateLiteral: ['quasis', 'expressions'],\r\n    SequenceExpression: ['expressions'],\r\n    SpreadElement: ['argument'],\r\n    RestElement: ['argument'],\r\n    ArrayPattern: ['elements'],\r\n    ObjectPattern: ['properties'],\r\n    AssignmentPattern: ['left', 'right'],\r\n    YieldExpression: ['argument'],\r\n    AwaitExpression: ['argument'],\r\n    ImportDeclaration: ['specifiers', 'source'],\r\n    ImportSpecifier: ['imported', 'local'],\r\n    ImportDefaultSpecifier: ['local'],\r\n    ImportNamespaceSpecifier: ['local'],\r\n    ExportSpecifier: ['exported', 'local']\r\n  };\r\n\r\n  const properties = childProperties[node.type];\r\n  if (properties) {\r\n    for (const prop of properties) {\r\n      const value = (node as any)[prop];\r\n      if (Array.isArray(value)) {\r\n        children.push(...value.filter(Boolean));\r\n      } else if (value) {\r\n        children.push(value);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Debug logging for function nodes\r\n  if (node.type === 'FunctionDeclaration' ||\r\n      node.type === 'ArrowFunctionExpression' ||\r\n      node.type === 'FunctionExpression') {\r\n    console.log(`Found ${children.length} children for ${node.type}:`, {\r\n      type: node.type,\r\n      id: (node as any).id?.name,\r\n      loc: node.loc,\r\n      children: children.map(child => ({\r\n        type: child.type,\r\n        loc: child.loc\r\n      }))\r\n    });\r\n  }\r\n\r\n  return children;\r\n}\r\n\r\nexport function calculateComplexity(node: BabelNode): number {\r\n  let complexity = 1;\r\n\r\n  // Early exit para nodos simples\r\n  if (!node || \r\n      node.type === 'StringLiteral' || \r\n      node.type === 'NumericLiteral' || \r\n      node.type === 'BooleanLiteral' ||\r\n      node.type === 'NullLiteral' ||\r\n      node.type === 'RegExpLiteral') {\r\n    return complexity;\r\n  }\r\n\r\n  // Incrementar complejidad solo para nodos de control de flujo\r\n  if (node.type === 'IfStatement' ||\r\n      node.type === 'SwitchCase' ||\r\n      node.type === 'ForStatement' ||\r\n      node.type === 'WhileStatement' ||\r\n      node.type === 'DoWhileStatement' ||\r\n      node.type === 'CatchClause' ||\r\n      node.type === 'ConditionalExpression') {\r\n    complexity++;\r\n  }\r\n\r\n  // Recorrer hijos solo si es necesario\r\n  const children = getChildren(node);\r\n  for (const child of children) {\r\n    complexity += calculateComplexity(child);\r\n  }\r\n\r\n  return complexity;\r\n}\r\n\r\nexport function parseFile(content: string) {\r\n  return parse(content, {\r\n    sourceType: 'module',\r\n    plugins: [\r\n      'jsx',\r\n      'typescript',\r\n      'classProperties',\r\n      'decorators-legacy',\r\n      'asyncGenerators',\r\n      'functionBind',\r\n      'functionSent',\r\n      'dynamicImport',\r\n      'doExpressions',\r\n      'objectRestSpread',\r\n      'optionalCatchBinding',\r\n      'optionalChaining',\r\n      ['pipelineOperator', { proposal: 'minimal' }],\r\n      'throwExpressions',\r\n      'classPrivateProperties',\r\n      'classPrivateMethods',\r\n      'exportDefaultFrom',\r\n      'exportNamespaceFrom',\r\n      'partialApplication',\r\n      'recordAndTuple',\r\n      'throwExpressions',\r\n      'topLevelAwait'\r\n    ],\r\n    errorRecovery: true,\r\n    allowAwaitOutsideFunction: true,\r\n    allowImportExportEverywhere: true,\r\n    allowReturnOutsideFunction: true,\r\n    allowSuperOutsideMethod: true,\r\n    allowUndeclaredExports: true,\r\n    ranges: true,\r\n    tokens: true\r\n  });\r\n} "],"mappings":"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","names":["node"]}